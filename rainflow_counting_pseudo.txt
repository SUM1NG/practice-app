Ask the user for file_path to read a csv file.
Remove any quotation marks or any other characters that will cause an error while defining a path and file name.
If the csv file is not in csv format, then convert the file into csv encoding utf-8.
Then ask the user for the x_name for the x_axis. 
Then ask the user for multiple y_name for the y_axis, separated by comma.

Then read the csv file.
The first row of the csv file contains the names of parameters.
The second row contains the units of said parameters.
Then from the third row, data is stored till the final row.

Then create a new csv file in the same directory,
naming it by adding a prefix, "[processed]".
delete all columns that are not addressed by the user,
add a blank row after the row that contains units, this will be denoting the sampling rate of the data.
The sampling rate is calculated by counting the number of blanks between the values for each of the y_axis.
If there is no blank rows between values, then the parameter's sampling rate is 16.
If there is one, then it is 8.
If there are three, then it is 4.
If there are seven, then it is 2.
If there are fifteen, then it is 1.
If there is an even number of blanks, or number of blanks not listed above, or if there are more than 15 blanks, it is an error, notify the user, for which y_axis the specific sampling rate error occurred.

In the new csv file, 
then if the values for the y_axis columns repeat with exactly the same values,
then replace the values with the lowest value in that column.

Then for all the rows that do not contain a value in the y_axis columns,
unless it is the first or the last row, fill the rows with the average of values above and below.
Also, notify the user in the event for all the above cases.

Then from the csv file, create a dictionary that:
stores the names as keys for both the x and y axis, 
storing only those addressed by the user.
Then store corresponding units and data as values,
making the data as a list inside the dictionary.

In the data, if there is a

Draw a graph with the x_axis and y_axis, use different colors for each of the y_axis, and notate each of the graph lines to the corresponding y_name, having the name above the line, aligned to the right edge of the graph.
Make the graph so that the width is 800px, height is 400px.
The Y axis should be notched in 15 even lines.
If there are negative values
The X axis should be notched in 20 even lines.

Apply a noise filter with adjustable limiter variable to the data.

Then for all y_names, using the following four-point rainflow algorithm:

# Rainflow algorithm
def rainflow(data):
    stack = []
    cycles = []
    for x in data:
        while len(stack) >= 2:
            [x1, x2, x3] = [stack[-2], stack[-1], x]
            if x1 <= x2 >= x3 or x1 >= x2 <= x3:
                if len(stack) >= 3 and (stack[-3] < x2 > x or stack[-3] > x2 < x):
                    break
                cycles.append((x1,x2))
                stack.pop(-1)
            else:
                break
        stack.append(x)
    for i in range(len(stack) - 1):
        cycles.append((stack[i], stack[i+1]))
    return cycles

plot the result in a distribution graph for each of the y_names